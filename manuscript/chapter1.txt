#Thinking Functionally in PHP?

##Introduction
That's right! Functional Programming in PHP. The PHP community has come a long way since the early starts of PHP mainly as a procedular, imperative language. Now, since PHP 5, you've become an Object-Oriented (OO) PHP developer. You take advantage of classes, abstract classes, and interfaces to properly implement the guiding OO principles called polymorphism, inheritance, and encapsulation. All of this comes into play when building rich domain models utilizing all of the coolest design patterns. Have you been able to reduce the development effort of building large PHP applications? Certainly. But is complexity still an issue and bugs frequent? Is your application easy to unit test? How reusable is your code?  

The PHP applications of yesterday are no match for the complex, dynamic, and distributed applications of today. It's commonplace now that our users demand that their applications run in cloud environments, integrated with a network of third-party services, and expect SLAs to hold at above 99%. It's always that balanc of low cost and return of investment against our desire to build robust, maintainable architectures. 

Naturally, as developers, we gravitate towards MVC frameworks that help us create an extensible and clean system design with scaffolding and plubming for routing, templates, persistence models, services, dependency injection (DI), and built-in integration with database servers. Despite all of this, our business logic code is still becoming hard to reason about, and this is becasue we still use shared variables, mutable state, monolithic functions, and others. These seamingly small concerns, which we're taught to be bad practices but do them anyway, are what functional programming encourages and challenges you to pay close attention to.  

Object-oriented design certainly moves the needle in the right direction, but we need more. Perhaps you’ve been hearin about functional programming (FP) in recent years. Language manufacturers are placing functional artifacts into their languages. Hence, Java, JavaScript, F#, C#, Scala, Python, Ruby, all have some form of functional features. Moreover, the industry is realizing that writing code functionally is opening the door to very clean and extensible architectures. Companies like Netflix have bet their success on reactive systems, which are built heavily on functional ideas. 

If you didn't know that PHP also supports writing functional code, then you’ve picked up the right book. Functional programming (FP) is the programming paradigm you need. While based on very simple concepts, FP requires a shift in the way you think about a problem. FP isn’t a new tool or an API, but a different approach to problem solving that will become intuitive once you’ve understood its basic principles and how they can be used against the most complex tasks. 
But before we can get into all of this, you need to learn why thinking functionally is important and how it can help you tackle the complexities of PHP programs.
##Hello FP
Functional programming is not a framework or a tool, but a way of writing code, thinking functionally is radically different from thinking in object-oriented terms. So, how do you become functional? How do you begin to think functionally? Functional programming is actually very intuitive once you’ve grasped its essence. Unlearning old habits is actually the hardest part and can be a huge paradigm shift for most people that come from an object-oriented background. Before you can learn to think functionally, first you must learn what functional programming is.
In simple terms, functional programming is a software development style that places a major emphasis on the use of functions. You might say, “well, I already use functions on a day-to-day basis at work; what’s the difference?” As I mentioned earlier, functional programming requires you to think a bit differently about how to approach the tasks you are facing. Your goal will be to abstract entire control flows and operations on data with functions in order to avoid *side effects* and *reduce mutation of state* in your application. By practicing FP, you'll become an expert in certain language constructs that are rarely used in other paradigms, like taking advantage of closures and higher-order functions, which were introduced back in PHP 5.3. Both of these concepts are key to building the functional primitives that you'll be using in your code. 
Without further ado, let's start with a simple 'Hello FP' example. Creating a simple script is probably the easiest way to get PHP up and running, and that’s all you’ll need for this book. Becasue I want to focus more on the concept in this chapter, I'll use very simple examples and simple functions. As you move through the book, we'll tackle on more real-world examples that involve file systems, HTTP requests, databases, etc.~~~$file = fopen('ch01.txt', 'w');	
fwrite($file, 'Hello FP!'); //-> 9 bytes~~~This program is very simple, but because everything is hard-coded you can’t use it to display messages dynamically. Say you wanted to change the message contents or where it will be written to; you will need to rewrite this entire expression. Consider wrapping this code with a function and making these change-points parameters, so that you write it once and use it with any configuration.~~~function toFile($filename, $message) {    $file = fopen($filename, 'w');	     fwrite($file, $message);}toFile('ch01.txt', 'Hello FP'); //-> Hello FP~~~An improvement, indeed, but still not a completely reusable piece of code. Suppose your requirements change and now you need to repeat the message twice? Obviously, your reaction will be to change the business logic of `toFile` to support this
~~~function toFile($filename, $message) {    $file = fopen($filename, 'w');	     fwrite($file, $message. ' ' . $message);}toFile('ch01.txt', 'Hello FP'); //-> Hello FP Hello FP~~~
This simple thought process of creating parameterized functions to carry out simple tasks is a step in the right direction; however, it would be nice to minimize reaching into your core logic to support slight changes in requirements. We need to make code *extensible*. Thinking functionally involves treating parameters as not just simple scalar values but  also as functions themselves that provide additional functionality. Functional programming is a bit like using functions or (*callables*) on steroids because your sole objective is to evaluate and combine lots of functions with others to achieve greater behavior. I’ll fast-forward a bit and show you a sneak peek at this same program using a functional approach.~~~
$run = compose($writeFile, $addExclamation, $twice);
$run('Hello FP'); //-> Hello FP Hello FP Hello FP! ~~~Without a doubt, this looks radically different than the original. I'll highlight just a couple of things now. For starters, the file is not a scalar anymore; it’s a function or *callable* called `$writeFile`. Also, notice how I was able to split the logic of writing to a file from formatting the contents. Visually, it feels as though I'm creating a bigger function from smaller ones. In traditional PHP applications, it's rare to see functions used this way. We typically declare functions and invoke them directly. In FP, it's common to pass around function references.
The important aspect about this code sample above is that it captures the process of decomposing a program into smaller pieces that are more reusable, reliable, and easier to understand; then they are combined to form an entire program that is easier to reason about as a whole. Thinking about each of these simple functions individually is very easy. It also makes your programs easier to test. Every functional program follows this fundamental principle. Now I just introduced a new concept `compose`, itself a function, to invoke a series of other functions together. I’ll explain what this means later on and how to use to its fullest potential. Behind the scenes, it basically links each function in a chain-like manner by passing the return value of one as input to the next. In this case, the string “Hello FP” was  passed into `$twice`, its result passed into `addExclamation`, and the result finally passed into `$writeFile`. 

So, why does functional code look this way? I like to think of it as basically parameterizing your code so that you can easily change it in a non-invasive manner—like adjusting an algorithm’s initial conditions. This visual quality is not accidental. When comparing the functional to the non-functional solution, you may have noticed that there is a radical difference in style. Both achieve the same purpose, yet look very different. This is due to functional programming’s inherent declarative mode of development.
##Declarative codingFunctional programming is foremost a declarative programming paradigm. Declarative programs express a logical connection of operations without revealing how they’re implemented or how data actually flows through them. As you know, the more popular models used today in PHP are the procedural and  object-oriented, both imperative paradigms. Imperative programming treats a computer program as merely a sequence of top-to-bottom statements that change the state of the system in order to compute a result. Let’s take a look at a simple imperative example. Suppose you need to square all of the numbers in an array. An imperative program follows these steps~~~
$array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for($i = 0; $i < count($array); $i++) {
   $array[$i] = pow($array[$i], 2);
}
$array; //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]~~~Imperative programming tells the computer, in great detail, how to perform a certain task (looping through and applying the square formula to each number in this case). This is the most common way of writing this code and most likely will be your first approach to tackling this problem. Declarative programming, on the other hand, *separates program description from evaluation*. It focuses on the use of expressions to describe what the logic of a program is without necessarily specifying its control flow or state changes. This is done with the use of higher-order functions that establish a certain vocabulary, such as filtering, mapping, or reducing an array. These are just some of the common terms used a lot with FP. Shifting to a functional approach to tackle this same task, you only need to be concerned with applying the right behavior at each element and cede control of looping to other parts of the system. I can let PHP's `array_map()` do the work~~~
$square = function ($num) {
   return pow($num, 2);
};
array_map($square, $array);  //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]~~~The function `array_map()` also works with *callables* just like the `compose` function shown earlier. Notice a trend?Comparing this code to the one above, you see that you’ve freed yourself from the responsibility of properly managing a loop counter and array index access; put simply, the more code you have, the more places there are for bugs to occur. Also, standard loops are not reusable artifacts, only when they are abstracted withing functions. Abstracting loops with functions will allow you to take advantage of PHP's *callables* by means of its *anonymous function syntax* and *closures*. Unfortunately, at this point PHP doesn't have lambda expressions, but there's currently an open proposal that I hope will be included soon. Check out the RFC [here](https://wiki.php.net/rfc/arrow_functions). 
With lambda expressions the code above will look like:~~~array_map(function($num) => pow($num, 2), $array)~~~Functions like `array_map()` have other benefits: they are immutable. This is extremely important in multithreaded applications where threads share a common resource, but because this scenario is not that common in PHP, we won't discuss the benefits of FP in terms of paralelism. Nevertheless, becasue functional programs aim for statelessness and immutability as much as possible, your code has zero chance of changing or breaking global state that other functions might need within the same execution thread. To achieve this, I'll introduce pure functions.
##Pure functions and the problem with side effectsFunctional programming is based on the premise that you will build immutable programs based on pure functions as the building blocks of your business logic. A pure function has the following qualities:
* It depends only on the input provided and not on any hidden or external state that may change during its evaluation or between calls.* It doesn’t inflict changes beyond their scope, like modifying a global object or a parameter passed by reference, after its run.
Intuitively, any function that does not meet these requirements would be qualified as “impure.” Programming with immutability can feel rather strange at first. After all, the whole point of imperative design, which is what we’re accustomed to, is to declare that variables are to mutate from one statement to the next (they are “variable” after all). PHP doesn't make any distinctions between *values* (immutable variables) and standard variables--they're all declared with a "$" dollar sign. This is a very natural thing for us to do. Consider the following function~~~$counter = 0;                    function increment() {   GLOBAL $counter;   return ++$counter;    }~~~While I can't use language constructs to enforce that data be stored in constant, final, or immutable variables, once thing we can do is stop using global variables and the `GLOBAL` mechanism in PHP. A function like this is impure as it reads/modifies an external variable `$counter`, which is not local to the function’s scope (it could actually live in a complete different file). Generally, functions have side effects when reading from or writing to external resources. 
![Side effects](images/side_effect.png)Side effects are also a bad design because it causes your functions to *temporally coupled*, which means the execution of one can determine the outcome of the next. In functional programming, functions are reusable artifacts that can be evaluated in any order and continue to yield correct results. 

![Side effects](images/side_effect2.png)
Side effects can be very ubiquitous. At a theoretical level, a side effect could be one of the following: 
* Changing a variable, property or data structure globally
* Changing the original value of a function’s argument
* Processing user input
* Throwing an exception, unless it’s caught within the same function
* Printing to the screen or logging
* Querying the HMTL documents, browser cookies, or databases 
Now what practical value would you get from a program that couldn't do any of these things? Indeed, pure functions can be very hard to use in a world full of dynamic behavior and mutation-- the real world. But, to benefit from functional programming you don't need to avoid all of these; FP just provides a framework to help you manage them, while allowing you to separate the pure from the impure. Impure code produces externally visible side effects like the ones listed above, and in this book we’ll examine ways to deal with this.

For instance, I can easily refactor `increment` to declare that it requires you provide the current counter

~~~
/** @return int */
function increment($counter) {
   return ++$counter;    }
~~~
This pure functions is now not only immutable but also has a clear contract that describes clearly the information it needs to carry its task, making it simpler to understand and use. This is a simple example, of course, but this level of reasoning can be taken to any function. Generally, the goal will be to create functions that do one thing, and combine them together, instead of creating large monoloithic functions. As a rule of thumb, we can argue that, in the world of pure functions, the more parameters a function declares, the more complex the function becomes. 


