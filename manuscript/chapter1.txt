#Thinking Functionally in PHP?

##Introduction
That's right! Functional Programming in PHP. The PHP community has come a long way since the early starts of PHP mainly as a procedular, imperative language. Now, since PHP 5, you've become an Object-Oriented (OO) PHP developer. You take advantage of classes, abstract classes, and interfaces to properly implement the guiding OO principles called polymorphism, inheritance, and encapsulation. All of this comes into play when building rich domain models utilizing all of the coolest design patterns. Have you been able to reduce the development effort of building large PHP applications? Certainly. But is complexity still an issue and bugs frequent? Is your application easy to unit test? How reusable is your code?  

The PHP applications of yesterday are no match for the complex, dynamic, and distributed applications of today. It's commonplace now that our users demand that their applications run in cloud environments, integrated with a network of third-party services, and expect SLAs to hold at above 99%. It's always that balanc of low cost and return of investment against our desire to build robust, maintainable architectures. 

Naturally, as developers, we gravitate towards MVC frameworks that help us create an extensible and clean system design with scaffolding and plubming for routing, templates, persistence models, services, dependency injection (DI), and built-in integration with database servers. Despite all of this, our business logic code is still becoming hard to reason about, and this is becasue we still use shared variables, mutable state, monolithic functions, and others. These seamingly small concerns, which we're taught to be bad practices but do them anyway, are what functional programming encourages and challenges you to pay close attention to.  

Object-oriented design certainly moves the needle in the right direction, but we need more. Perhaps you’ve been hearin about functional programming (FP) in recent years. Language manufacturers are placing functional artifacts into their languages. Hence, Java, JavaScript, F#, C#, Scala, Python, Ruby, all have some form of functional features. Moreover, the industry is realizing that writing code functionally is opening the door to very clean and extensible architectures. Companies like Netflix have bet their success on reactive systems, which are built heavily on functional ideas. 

If you didn't know that PHP also supports writing functional code, then you’ve picked up the right book. Functional programming (FP) is the programming paradigm you need. While based on very simple concepts, FP requires a shift in the way you think about a problem. FP isn’t a new tool or an API, but a different approach to problem solving that will become intuitive once you’ve understood its basic principles and how they can be used against the most complex tasks. 
But before we can get into all of this, you need to learn why thinking functionally is important and how it can help you tackle the complexities of PHP programs.
##Hello FP
Functional programming is not a framework or a tool, but a way of writing code, thinking functionally is radically different from thinking in object-oriented terms. So, how do you become functional? How do you begin to think functionally? Functional programming is actually very intuitive once you’ve grasped its essence. Unlearning old habits is actually the hardest part and can be a huge paradigm shift for most people that come from an object-oriented background. Before you can learn to think functionally, first you must learn what functional programming is.
In simple terms, functional programming is a software development style that places a major emphasis on the use of functions. You might say, “well, I already use functions on a day-to-day basis at work; what’s the difference?” As I mentioned earlier, functional programming requires you to think a bit differently about how to approach the tasks you are facing. Your goal will be to abstract entire control flows and operations on data with functions in order to avoid *side effects* and *reduce mutation of state* in your application. By practicing FP, you'll become an expert in certain language constructs that are rarely used in other paradigms, like taking advantage of closures and higher-order functions, which were introduced back in PHP 5.3. Both of these concepts are key to building the functional primitives that you'll be using in your code. 
Without further ado, let's start with a simple 'Hello FP' example. Creating a simple script is probably the easiest way to get PHP up and running, and that’s all you’ll need for this book. Becasue I want to focus more on the concept in this chapter, I'll use very simple examples and simple functions. As you move through the book, we'll tackle on more real-world examples that involve file systems, HTTP requests, databases, etc.~~~$file = fopen('ch01.txt', 'w');	
fwrite($file, 'Hello FP!'); //-> 9 bytes~~~This program is very simple, but because everything is hard-coded you can’t use it to display messages dynamically. Say you wanted to change the message contents or where it will be written to; you will need to rewrite this entire expression. Consider wrapping this code with a function and making these change-points parameters, so that you write it once and use it with any configuration.~~~function toFile($filename, $message) {    $file = fopen($filename, 'w');	     fwrite($file, $message);}toFile('ch01.txt', 'Hello FP'); //-> Hello FP~~~An improvement, indeed, but still not a completely reusable piece of code. Suppose your requirements change and now you need to repeat the message twice? Obviously, your reaction will be to change the business logic of `toFile` to support this
~~~function toFile($filename, $message) {    $file = fopen($filename, 'w');	     fwrite($file, $message. ' ' . $message);}toFile('ch01.txt', 'Hello FP'); //-> Hello FP Hello FP~~~
This simple thought process of creating parameterized functions to carry out simple tasks is a step in the right direction; however, it would be nice to minimize reaching into your core logic to support slight changes in requirements. We need to make code *extensible*. Thinking functionally involves treating parameters as not just simple scalar values but  also as functions themselves that provide additional functionality. Functional programming is a bit like using functions or (*callables*) on steroids because your sole objective is to evaluate and combine lots of functions with others to achieve greater behavior. I’ll fast-forward a bit and show you a sneak peek at this same program using a functional approach.~~~
$run = compose($writeFile, $addExclamation, $twice);
$run('Hello FP'); //-> Hello FP Hello FP Hello FP! ~~~Without a doubt, this looks radically different than the original. I'll highlight just a couple of things now. For starters, the file is not a scalar anymore; it’s a function or *callable* called `$writeFile`. Also, notice how I was able to split the logic of writing to a file from formatting the contents. Visually, it feels as though I'm creating a bigger function from smaller ones. In traditional PHP applications, it's rare to see functions used this way. We typically declare functions and invoke them directly. In FP, it's common to pass around function references.
The important aspect about this code sample above is that it captures the process of decomposing a program into smaller pieces that are more reusable, reliable, and easier to understand; then they are combined to form an entire program that is easier to reason about as a whole. Thinking about each of these simple functions individually is very easy. Every functional program follows this fundamental principle. Now I just introduced a new concept `compose`, itself a function, to invoke a series of other functions together. I’ll explain what this means later on. Behind the scenes, it basically links each one in a chain-like manner by passing the return value of one as input to the next. In this case, the string “Hello FP” was  passed into `$twice`, its result passed into `addExclamation`, and the result finally passed into `$writeFile`. 
