#Thinking Functionally in PHP?

##Introduction
That's right! Functional Programming in PHP. The PHP community has come a long way since the early starts of PHP mainly as a procedular, imperative language. Now, since PHP 5, you've become an Object-Oriented (OO) PHP developer. You take advantage of classes, abstract classes, and interfaces to properly implement the guiding OO principles called polymorphism, inheritance, and encapsulation. All of this comes into play when building rich domain models utilizing all of the coolest design patterns. Have you been able to reduce the development effort of building large PHP applications? Certainly. But is complexity still an issue and bugs frequent? Is your application easy to unit test? How reusable is your code?  

The PHP applications of yesterday are no match for the complex, dynamic, and distributed applications of today. It's commonplace now that our users demand that their applications run in cloud environments, integrated with a network of third-party services, and expect SLAs to hold at above 99%. It's always that balanc of low cost and return of investment against our desire to build robust, maintainable architectures. 

Naturally, as developers, we gravitate towards MVC frameworks that help us create an extensible and clean system design with scaffolding and plubming for routing, templates, persistence models, services, dependency injection (DI), and built-in integration with database servers. Despite all of this, our business logic code is still becoming hard to reason about, and this is becasue we still use shared variables, mutable state, monolithic functions, and others. These seamingly small concerns, which we're taught to be bad practices but do them anyway, are what functional programming encourages and challenges you to pay close attention to.  

Object-oriented design certainly moves the needle in the right direction, but we need more. Perhaps you’ve been hearin about functional programming (FP) in recent years. Language manufacturers are placing functional artifacts into their languages. Hence, Java, JavaScript, F#, C#, Scala, Python, Ruby, all have some form of functional features. Moreover, the industry is realizing that writing code functionally is opening the door to very clean and extensible architectures. Companies like Netflix have bet their success on reactive systems, which are built heavily on functional ideas. 

If you didn't know that PHP also supports writing functional code, then you’ve picked up the right book. Functional programming (FP) is the programming paradigm you need. While based on very simple concepts, FP requires a shift in the way you think about a problem. FP isn’t a new tool or an API, but a different approach to problem solving that will become intuitive once you’ve understood its basic principles and how they can be used against the most complex tasks. 
But before we can get into all of this, you need to learn why thinking functionally is important and how it can help you tackle the complexities of PHP programs.
##Hello FP
Functional programming is not a framework or a tool, but a way of writing code, thinking functionally is radically different from thinking in object-oriented terms. So, how do you become functional? How do you begin to think functionally? Functional programming is actually very intuitive once you’ve grasped its essence. Unlearning old habits is actually the hardest part and can be a huge paradigm shift for most people that come from an object-oriented background. Before you can learn to think functionally, first you must learn what functional programming is.
In simple terms, functional programming is a software development style that places a major emphasis on the use of functions. You might say, “well, I already use functions on a day-to-day basis at work; what’s the difference?” As I mentioned earlier, functional programming requires you to think a bit differently about how to approach the tasks you are facing. Your goal will be to abstract entire control flows and operations on data with functions in order to avoid *side effects* and *reduce mutation of state* in your application. By practicing FP, you'll become an expert in certain language constructs that are rarely used in other paradigms, like taking advantage of closures and higher-order functions. Both of these concepts are key to building the functional primitives that you'll be using in your code. 
Without further ado, let's start with a simple 'Hello FP' example. ~~~
~~~Opening the browser and typing in some code is probably the easiest way to get JavaScript up and running, and that’s all you’ll need for this book.What better text to print than the good’ ol “Hello World”document.querySelector('#msg').innerHTML = '<h1>Hello World</h1>';This program is very simple, but because everything is hard-coded you can’t use it to display messages dynamically. Say you wanted to change the formatting, the contents, or perhaps change the target element; you will need to rewrite this entire expression. Perhaps you consider wrapping this code with a function and making these change-points parameters, so that you write it once and use it with any configuration.function printMessage(elementId, format, message) {     document.querySelector(`#${elementId}`).innerHTML =         `<${format}>${message}</${format}>`;}printMessage('msg', 'h1','Hello World');An improvement, indeed, but still not a completely reusable piece of code. Suppose you consider writing to a file instead of an HTML page? You need to take this simple thought process of creating parameterized functions to a different level, where parameters are not just simple scalar values but can also be functions themselves that provide additional functionality. Functional programming is a bit like using functions on steroids because your sole objective is to evaluate and combine lots of functions with others to achieve greater behavior. I’ll fast-forward a bit and show you a sneak peek at this same program using a functional approach.Listing 1.1 Functional printMessage var printMessage = run(addToDom('msg'), h1, echo);printMessage('Hello World');Without a doubt, this looks radically different than the original. For starters, h1 is not a scalar anymore; it’s a function just like addToDom and echo. Visually, it feels as though you’re creating a function from smaller ones. There’s a reason for this madness. Listing 1.1 captures the process of decomposing a program into smaller pieces that are more reusable, reliable, and easier to understand, and then combining them to form an entire program that is easier to reason about as a whole. Every functional program follows this fundamental principle. For the time being, I’ll use a magical function, run, to invoke a series of functions together such as addToDom, h1, and echo. I’ll explain what run is later. Behind the scenes, it basically links each one in a chain-like manner by passing the return value of one as input to the next. In this case, the string “Hello World” returned from echo is passed into h1, and the result finally passed into addToDom. So, why does the functional solution look this way? I like to think of it as basically parameterizing your code so that you can easily change it in a non-invasive manner—like adjusting an algorithm’s initial conditions. Parting from this, I can now easily augment printMessage to repeat the message twice, use an h2 header, and write to the console instead, all without having to rewrite any of its internal logic.Listing 1.2 Extending printMessagevar printMessage = run(console.log, repeat(3), h2, echo);printMessage('Get Functional');This prevalent visual quality is not accidental. When comparing the functional to the non-functional solution, you may have noticed that there is a radical difference in style. Both print the same output, yet look very different. This is due to functional programming’s inherent declarative mode of development. In order to fully understand functional programming, first you must learn the fundamental concepts on which it’s based:♣	Declarative programming♣	Pure functions♣	Referential transparency♣	Immutability1.2.1	Functional programming is declarativeFunctional programming falls under the umbrella of declarative programming paradigms. A paradigm that expresses a set of operations without revealing how they’re implemented or how data flows through them. The more popular models used today, however, are imperative or procedural, which are supported in most structured and object-oriented languages, like Java, C#, C++ and others. Imperative programming treats a computer program as merely a sequence of top-to-bottom statements that change the state of the system in order to compute a result. Let’s take a look at a simple imperative example. Suppose you need to square all of the numbers in an array. An imperative program follows these stepsvar array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];for(let i = 0; i < array.length; i++) {   array[i] = Math.pow(array[i], 2);}array; //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]Imperative programming tells the computer, in great detail, how to perform a certain task (looping through and applying the square formula to each number in this case). This is the most common way of writing this code and most likely will be your first approach to tackling this problem. Declarative programming, on the other hand, separates program description from evaluation. It focuses on the use of expressions to describe what the logic of a program is without necessarily specifying its control flow or state changes. An example of declarative programming is found in SQL statements. SQL queries are composed of statements that describe what the outcome of a query should look like, abstracting the internal mechanism for data retrieval. In chapter 3, I show an example of using a SQL-like overlay over your functional code to give meaning to both your application as well as the data that runs through it. Shifting to a functional approach to tackle this same task, you only need to be concerned with applying the right behavior at each element and cede control of looping to other parts of the system. I can let Array.map() do most of the heavy lifting[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(      function(num) {         return Math.pow(num, 2);  //#A       });   //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]#A - Passes a function that computes the square of each number Comparing this code to the one above, you see that you’ve freed yourself from the responsibility of properly managing a loop counter and array index access; put simply, the more code you have, the more places there are for bugs to occur. Also, standard loops are not reusable artifacts, only when they are abstracted with functions. And that’s precisely what we’ll do. In chapter 3, I demonstrate how to remove manual loops completely from your code in favor of first-class, high-order functions like map, reduce, and filter, which accept functions as parameters so that your code is more reusable, extensible, and declarative. This is what I did with the magical run function in listings 1.1 and 1.2 earlier.Abstracting loops with functions will allow you to take advantage of lambda expressions or “arrow functions” introduced in ES6 JavaScript. Lambda expressions provide a very succinct alternative to anonymous functions that can be passed in as a function argument. In the spirit of writing less[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => Math.pow(num, 2));//-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]Translating lambda notation to regular function notationLambda expressions provide an enormous syntactical advantage to regular function notations as they reduce the structure of a function call down to the most important pieces. This ES6 lambda expression	num => Math.pow(num, 2)is equivalent to the following function     function(num) {      return Math.pow(num, 2);   }Why remove loops from our code? A loop is an imperative control structures that’s hard to reuse and difficult to plug into other operations. In addition, it implies code that is constantly changing or mutating in response to new iterations. You’ll learn that functional programs aim for statelessness and immutability as much as possible. Stateless code has zero chance of changing or breaking global state. To achieve this, we will use functions that avoid side effects and changes of state, known as pure functions.1.2.2	Pure functions and the problem with side effectsFunctional programming is based on the premise that you will build immutable programs based on the building blocks of pure functions, which have the following qualities:♣	It depends only on the input provided and not on any hidden or external state that may change during its evaluation or between calls.♣	It doesn’t inflict changes beyond their scope, like modifying a global object or a parameter passed by reference.Intuitively, any function that does not meet these requirements would be qualified as “impure.” Programming with immutability can feel rather strange at first. After all, the whole point of imperative design, which is what we’re accustomed to, is to declare that variables are to mutate from one statement to the next (they are “variable” after all). This is a very natural thing for us to do. Consider the following functionvar counter = 0;                    function increment() {   return ++counter;       }This function is impure as it reads/modifies an external variable counter, which is not local to the function’s scope. Generally, functions have side effects when reading from or writing to external resources, as shown in figure 1.1. Another example is the popular function Date.now(); its output is certainly not predicable and consistent because it always depends on a constantly changing factor, time.Figure 1.1. Function increment() causes side effects by reading/modifying an external variable counter. Its result is unpredictable since counter can change at any time between calls.In this case, counter is accessed via an implicit global variable (in browser-based JavaScript, it’s the window object). Another common side effect occurs when accessing instance data via the this keyword. The behavior of this in JavaScript is unlike any other programming language because it determines the runtime context of a function. This often leads to cope that is very hard to reason about and why we’ll avoid it when possible. I will revisit this topic in the next chapter. Generally, side effects can occur in many situations, including:♣	Changing a variable, property or data structure globally♣	Changing the original value of a function’s argument♣	Processing user input♣	Throwing an exception, unless it’s caught within the same function♣	Printing to the screen or logging♣	Querying the HMTL documents, browser cookies, or databases So, if you are unable to create and modify objects or print to the console, what practical value would you get from a program like this? Indeed, pure functions can be very hard to use in a world full of dynamic behavior and mutation. But, practical functional programming doesn’t restrict absolutely all changes of state; it just provides a framework to help you manage and reduce it, while allowing you to separate the pure from the impure. Impure code produces externally visible side effects like the ones listed above, and in this book we’ll examine ways to deal with cope with this.To talk more concretely about these issues, suppose you’re a developer in a team implementing an application to manage a school’s student data. Listing 1.3 shows a small imperative program that finds a student record by social security number and renders it on the browser (again the use of the browser is immaterial, I could just as easily write to the console, database, or a file). I will refer to and expand this program throughout the book as a typical, real-world scenario that involves side effects by interacting with an external local object store (like an array of objects) and doing some level of IO. Listing 1.3 Imperative showStudent function with side effectsfunction showStudent(ssn) {    var student = db.get(ssn); //#A    if(student !== null) {        document.querySelector(`#${elementId}`).innerHTML = //#B          `${student.ssn},              ${student.firstname},           ${student.lastname}`;      }    else {        throw new Error('Student not found!'); //#C    }}  showStudent('444-44-4444'); //#D#A - Access object storage to look up a student by SSN. Assume this is a synchronous operation for now; we will deal with asynchronous code much later in the book.#B - Reaches outside of the function to read the elementId#C - Throws exception for an invalid student #D - Runs this program with SSN 444-44-4444 and appends the student details to the pageLet’s analyze this code further because this function clearly exposes a few side effects that ripple beyond its scope:♣	It interacts with an external variable (db) for data access since the function signature doesn’t declare this parameter. At any point in time, this reference could become null or change from one call to the next yielding completely different results and compromising the integrity of your program.♣	The global variable elementId can change at any time without our control. ♣	HTML elements are directly modified. The HTML document (DOM) is itself a mutable, shared, and global resource.♣	Finally, it can potentially throw an exception if the student isn’t found, which causes your entire program stack to unwind and end abruptly. The function in listing 1.3 relies on external resources, which makes your code really inflexible, hard to work with, and hard to test. Pure functions, on the other hand, have clear contracts as part of their signatures that describe clearly all of the function’s formal parameters (set of inputs), making them simpler to understand and use.Let’s put our functional hat on and use what you learned from the simple printMessage program against this real-life scenario. As you become more comfortable with functional programming, we will continue to improve this implementation with new techniques. At the moment, however, we can make two simple enhancements:1.	Separate this long function into shorter functions, each with a single purpose. 2.	Reduce the amount of side effects by explicitly defining all arguments needed for the functions to carry out their job.Let’s begin by separating the activities of fetching the student record from displaying it on the screen. Granted, the side effects from interacting with an external storage system and the DOM are unavoidable, but at least now they can become more manageable and singled out from the main logic. To do this, I will introduce now a very popular functional programming technique called currying. With currying, I can partially set some of the arguments of a function in order to reduce them down to one. As you’ll see in listing 1.4, I can apply curry to find and append to convert them into unary functions that can easily combine via run.Listing 1.4 Decomposing the showStudent programvar find = curry(function (db, id) { //#A    var obj =  db.get(id);               if(obj === null) {       throw new Error('Object not found!');    }    return obj;});var csv = (student) { //#B   return `${student.ssn}, ${student.firstname}, ${student.lastname}`;};var append = curry(function (elementId, info) { //#C   document.querySelector(elementId).innerHTML = info;});#A - The find function just needs a reference to the object store and the ID of the student to lookup#B - Convert student object into csv (comma-separated values)#C - To display a student’s details on the page, I need the element ID and the student dataIt’s not necessary to understand currying now, but it’s important to understand that being able to reduce the length of these functions allows me to write showStudent as simply the combination of these smaller partsvar showStudent = run(   append('#student-info'), //#A   csv,    find(db)); //#BshowStudent('444-44-4444');#A - Partially set the HTML element ID to use within the function#B - Partially set a data access object to point to the students tableWhile this program has only been marginally improved, it already begins to show lots of benefits:•	First of all, it’s a lot more flexible as it now has three reusable components. •	This fine-grained function reuse is a strategy for increasing your productivity because you can dramatically reduce the footprint of code that must be actively managed. •	You’ve dramatically enhanced the level of readability of your code by following a declarative style that provides a clear view of the high-level steps carried out by this program.•	More importantly, interaction with the HTML objects has been moved into its own function, isolating the pure from the non-pure (impure) behavior. I’ll explain currying and managing pure and impure parts in depth in chapter 4. This program still has some loose ends that need to be tighten, but reducing side effects will make it less brittle to changing external conditions. If you look closer at the find function, you’ll notice it has a null-check branching statement that can produce an exception. For many reasons, which we will study later on, it is beneficial to guarantee a consistent return value from our functions, making its result consistent and predicable. This is a quality of pure functions called referential transparency.1.2.3	Referential transparency and substitutabilityReferential transparency is a more formal way of defining a pure function. “Purity” in this sense refers to the existence of a pure mapping between a function’s arguments and its return value. Hence, if a function consistently yields the same result on the same input, it is said to be referentially transparent. For instance, the stateful increment function shown earlier isn’t referentially transparent because its return value is heavily dependent on the external variable counter. Here it is again var counter = 0;function increment() {    return ++counter;}In order to make it referentially transparent, I need to remove its dependent state, the outer variable, and make it an explicit formal parameter of the function signature. I’ll convert it to ES6 lambda form var increment = counter => counter + 1;Now, this function is stable and always returns the same output when provided the same input. If this were not the case, it must mean that that the function’s return value is being influenced by some external factor. We seek this quality in our functions because it not only makes our code easier to test, but also allows us to reason about entire programs much easier. Referential transparency or equational correctness is inherited from math, but functions in programming languages behave nothing like mathematical functions; so achieving referential transparency is strictly on us. Using our magical run function again, here’s how you would use the imperative versus the functional version of increment.Figure 1.2 Compares working with imperative and functional versions of increment. The result of the imperative version is unpredictable and can be inconsistent because the external counter variable may change at any time, compromising the result of successive invocations of the function. The referentially transparent, functional version is equationally correct always and leaves no room for errors.Programs built this way are much easier to reason about because they allow you to form a mental model about the state of the system and achieve the desired outcome through rewriting or substitution. Let’s look at this more concretely and assume that any program can be defined as a set of functions that process a given input and produce an output. Here it is in pseudo formProgram = [Input] + [func1, func2, func3, ...] -> Output If these functions [func1, func2, func3, ...] are pure, I can easily rewrite this program by inlining the values produced by them [val1, val2, val3, ...] without altering its result. Consider a simple example of computing a student’s average gradevar input = [80, 90, 100];var average = (arr) => divide(sum(arr), size(arr));average (input); //-> 90Because the functions sum and size are referentially transparent, then I can easily rewrite this expression for the given input asvar average = divide(270, 3); //-> 90Since divide is always pure, it can be rewritten further using its mathematical notation; so for this input the average will always be 270/3 = 90. Referential transparency makes it possible to reason about programs in this systematic, almost mathematical, way. The entire program could be implemented as var sum = (total, current) => total + current;var total = arr => input.reduce(sum); //#Avar size = arr => arr.length;var divide = (a, b) => a / b;var average = arr => divide(sum(arr), size(arr)); //#Baverage(input); //-> 90#A - Another new function, reduce. Just like map, reduce iterates through an entire collection. By providing a sum function, it can be used to tally the result of adding each number in the array. #B - In chapter 4, we will look at ways of combining an average function into a composition.While I don’t plan on applying equational reasoning to every program in the book, it’s important to understand that this is implicit into any purely functional program, and that it wouldn’t be possible otherwise if functions had side effects. In chapter 6, I will come back to the importance of this principle in the context of unit testing functional code. Defining all function arguments up-front is avoids side effects in most cases, as with scalar values, but when objects are passed by reference, we must be cautious not to inadvertently mutate it. 1.2.4	Preserving immutable dataImmutable data is one that can’t be changed after it has been created. In JavaScript, as with many other languages, all primitive types (String, Number, and so on) are inherently immutable. However, other objects like arrays are not immutable and even if they’re passed as input to a function you can still cause a side effect by changing its original content. Consider this simple array sorting codevar sortDesc = function (arr) {  return arr.sort(function (a, b) {     return b - a;  }); }At a glance this code seems perfectly fine and side effect free. It does what you’d expect it to do, you provide an array and it will return the same array sorted in descending order var arr = [1,2,3,4,5,6,7,8,9];sortDesc(arr); //-> [9,8,7,6,5,4,3,2,1]Unfortunately, the Array.sort function is stateful and causes the side effect of sorting the array in place—the original reference is changed. This is a serious flaw in the language and one that we will overcome in the next chapters. Now that you’ve caught a glimpse of the fundamental principles behind functional programming (declarative, pure, and immutable), perhaps now we can express what it is more succinctly.Functional programming refers to the declarative evaluation of pure functions to create immutable programs by avoiding externally observable side effects. Not such a mouthful after all. I have only scratched the surface in terms of the practical benefits of writing functional applications, but by now you’re beginning to understand what it means to think with this mindset. Most of the issues JavaScript developers face nowadays are due to the heavy use of large functions that rely heavily on externally shared variables, lots of branching, and no clear structure. Unfortunately, this is the situation of many JavaScript applications today, even successful ones, that are made up of many files that execute together forming a shared mesh of mutable, global data that can be very hard to track and debug. Forcing us to think in terms of pure operations and looking at functions as sealed units of work that never mutate data can definitely reduce the potential for lots of bugs. Understanding these core principles is important to reap the benefits functional programming brings to your code, which will guide you on the right path to overcome complexity.1.3	Benefits of functional programmingIn order to benefit from functional programming, you must learn to think functionally and have the proper tools. In this section, I introduce some core techniques that are indispensable for your toolbox in order to develop your functional awareness—the instinct of looking at problems as a combination of simple functions that together provide a complete solution. Also, the topics introduced in this section serve as a brief introduction to some of the upcoming chapters in the book; if a concept is hard to grasp now, don’t worry; it will become clearer as you progress through the rest of the chapters. Now, let’s explore at a high level the benefits functional programming brings to your JavaScript applications; in the following subsections, I explain how it can♣	Encourage you to decompose tasks into simple functions. ♣	Process data using fluent chains.♣	Decrease the complexity of event-driven code by enabling reactive paradigms.1.3.1	Encourage the decomposition of complex tasksAt a high level, functional programming is effectively the interplay between decomposition (breaking programs into small pieces) and composition (joining the pieces back together). It is this duality that makes functional programs modular and so effective. As I mentioned previously, the unit of modularity, or “unit of work” is the function itself. Thinking functionally typically begins with decomposition by learning to break up a particular task into logical subtasks (functions), as shown in the decomposition of showStudent in figure 1.3.Figure 1.3 The process of decomposing programs showStudent into smaller parts. These subtasks are independent and simpler to understand, so that when combined help solve the bigger picture.If need be, these subtasks can be decomposed further until arriving at simpler, pure functions, each of which is an independent unit of work. Remember that this was the thought process I followed when refactoring showStudent in listing 1.4. Modularization in functional programming is closely related to the singularity principle, which states that functions should have a single purpose—this was also evident in the code for average shown earlier. Purity and referential transparency will encourage you to think this way because in order to glue simple functions together they must agree on the types of inputs and outputs. From referential transparency, we learn that a function’s complexity is sometimes directly related to the number of arguments it receives; this is merely a practical observation and not a formal concept that indicates the lower the number of function parameters, the simpler the function tends to be. All along, I’ve been using run to combine functions together to make up whole programs. It’s time to uncover this dark magic. In reality, run is really just an alias for one the most important techniques: composition. The composition of two functions is another function that results from taking the output of one and plugging it into the next. Assume you have two functions f and g; formally, this can be expressed asf  g = f(g(x))This formula reads “f composed of g,” which will create a loose, type-safe relationship between g’s return value and f’s argument. The requirement for two functions to be compatible is that they must agree in the number of arguments as well as their types. We will look at this closely in chapter 3.  For now, let’s diagram the composition of showStudent in figure 1.4, this time I’ll use the correct function composevar showStudent = compose(append('#student-info'), csv, find(db));showStudent('444-44-4444');Figure 1.4 Showing the flow of data when composing two functions. The return value from find must be compatible in type and arity with the arguments to csv, which in turn returns information that append can use. Note: in order to make the flow of data clear, I flipped the order of function calls. Understanding compose is crucial to learning how to implementing modularity and reusability in functional applications; I will discuss this at length in chapter 4. Functional composition leads to code in which the meaning of the entire expression can be understood from the meaning of its individual pieces; a quality that becomes very hard to achieve in other paradigms. In addition, functional composition raises the level of abstraction so that you can clearly outline all the steps performed in this code without being exposed to any of its underlying details. Because compose accepts other functions as arguments, it is known as a high-order function (chapter 2 takes a deep dive into JavaScript high-order functions). But composition is not the only way to create fluent, modular code; in this book you’ll also learn how to build sequences of operations by connecting operations in a chain-like manner.1.3.2	Processing data using fluent chainsIn addition to map, you can import a repertoire many high-order functions into any JavaScript project through some very powerful and optimized functional libraries. In chapters 3 and 4, I give a tour of many of these high-order functions implemented in popular JavaScript functional toolkits like Lodash.js and Ramda.js; both overlap in many aspects but each brings unique features that can facilitate assembling function chains. If you’ve written some JQuery code before, you’re probably very familiar with this idiom. A chain is a sequential invocation of functions that share a common object return value (such as the $ or jQuery object). Like composition, this idiom allows you to write very terse and concise code and it’s typically used a lot in in functional as well reactive programming JavaScript libraries (more on this later). To show this I’ll tackle a different problem. Suppose you are tasked to write a program that computes the average grade for students that have enrolled in more than one class. Given an array of enrollment data let enrollment = [  {enrolled: 2, grade: 100},  {enrolled: 2, grade: 80},  {enrolled: 1, grade: 89}];An imperative approach might look like thisvar totalGrades = 0;var totalStudentsFound = 0;for(let i = 0; i < enrollment.length; i++) {    let student = enrollment [i];    if(student !== null) {       if(student.enrolled > 1) {          totalGrades+= student.grade;          totalStudentsFound++;       }    } } var average = totalGrades / totalStudentsFound; //-> 90Just as we did before, decomposing this problem with a functional mindset, you can identify three major steps: ♣	Selecting the proper set of students (whose enrollment is greater than one)♣	Extracting their grades♣	Calculating their average gradeNow I can use Lodash to stitch together functions representing these steps forming a functional chain, as shown in listing 1.5 (for a full explanation of what each of these functions do, you can visit the appendix for directions on where to find the proper documentation). A function chain is a lazy evaluated program, which means it will defer its execution until needed. This benefits performance because you can avoid executing entire sequences of code that won’t get used any where else, saving precious CPU cycles. This effectively simulates the call-by-need behavior built into other functional languages.Listing 1.5 Programming with function chains_.chain(enrollment)  .filter(student => student.enrolled > 1)  .pluck('grade')  .average()     .value(); //#A       //-> 90#A – Calling _.value() is what kicks off the execution of all operations in the chainDon’t be too concerned at this point with everything that’s happening in this code. For now, compare it to the imperative version, and notice how I was able to completely eliminate the need to declare and change variables, loops, and if-else statements. As you’ll learn in chapter 7, many imperative control flow mechanisms like loops and branches increase the level of complexity of your functions since they execute different paths depending on certain conditions, making them incredibly difficult to test. To be fair though, I also skipped a lot of error handling code that typical real-world programs have. Earlier, I mentioned that throwing exceptions was a cause of side effects. Exceptions don’t actually exist in academic functional programming, but in real life you won’t be able to escape them. There’s a distinction between pure error handling and exception handling. Our goal is to implement pure error handling as much as possible, and allow exceptions to fire in truly exceptional conditions, just as the ones described earlier. Fortunately, by applying some purely functional design patterns we won’t need to sacrifice this level of expressiveness to provide robust error handling logic to our code. I will make this the main topic of discussion in chapter 5.So far you’ve seen how functional programming can help us create modular, testable, and extensible applications. So, how well does it work when you need to interact with asynchronous or event-based data coming from user input, remote web requests, file systems, or persistent storage?1.3.3	React to the complexity of asynchronous applicationsIf you remember the last time you had to fetch remote data, handle user input, or interact with local storage, you probably recall writing entire sections of business logic into nested sequences of callback functions. This callback pattern breaks the linear flow of your code and becomes really hard to read because it’s cluttered with nested forms of success and error handling logic. This is all about to change.As I said earlier, learning functional programming, especially for JavaScript developers, is extremely important today. When building large applications, a lot of the focus has shifted from object-oriented frameworks like Backbone.js into ones that favor a reactive programming paradigm. Web frameworks like Angular.js are still very widely used today, but there are new players in the field, such as Rx.js, that embrace the power of functional programming to tackle very challenging tasks. Reactive programming is probably one of the most exciting and interesting applications of functional programming. You can use it to dramatically reduce the complexity in asynchronous and event-driven code that we, as JavaScript developers, deal with on a daily basis on the client as well as the server.The main benefit of adopting a reactive paradigm is that it raises the level of abstraction of your code, allowing you to focus on specific business logic, while forgetting about the arduous boilerplate code associated with setting up asynchronous and event-based programs. Also, this emerging paradigm takes full advantage of functional programming’s ability to chain or compose functions together. Events come in many flavors, mouse clicks, text field changes, focus changes, handling a new HTTP request, database queries, file writes, and so on. Suppose you need to read and validate a student’s SSN. A typical imperative approach might look like this.Listing 1.6 Imperative program that reads and validates a student’s SSNvar valid = false;var elem = document.querySelector('#student-ssn');elem.onkeyup = function(event) {   var val = elem.value;  //#A   if(val !== null && val.length !== 0) {       val = val.replace(/^\s*|\s*$|\-s/g, ''); //#B      if(val.length === 9) {  //#C         console.log(`Valid SSN: ${val}!`);         valid = true; //#A       }              }   else {      console.log(`Invalid SSN: ${val}!`);         }};#A - Side effects in reaching out to data outside the function scope#B - Trim and clean up input. Mutating data in place#C - Nested branching logicFor such a simple task, this is beginning to look very complex and lacks the level desired of modularity with all business logic in a single place. Also, this function is not reusable due its dependency on external state. Because reactive is based on functional programing, it benefits from the use of pure functions in order to process data with the same familiar operations like map and reduce and the terseness of lambda expressions. So, learning functional is half the battle when learning reactive! This paradigm is enabled through a very important artifact called an observable. Observables allow you to subscribe to a stream of data that you can process by composing and chaining operations together very elegantly. Let’s see it in action and subscribe to a simple input field for a student’s SSN.Listing 1.7 Functional program that reads and validates a student’s SSNRx.Observable.fromEvent(document.querySelector('#student-ssn'), 'keyup')   .map(input => input.srcElement.value)   .filter(ssn => ssn !== null && ssn.length !== 0)   .map(ssn => ssn.replace(/^\s*|\s*$|\-/g, ''))   .skipWhile(ssn => ssn.length !== 9)   .subscribe(      validSsn => console.log(`Valid SSN ${validSsn}`)    );Can you see the similarity between listing 1.7 and programming with chains in listing 1.5? This shows that whether you’re processing a collection of elements or user input, it’s all abstracted out and treated in the exact same manner. I’ll have much more to say about this later on in chapter 8.One of the most important takeaways is that all of the operations performed in listing 1.7 are completely immutable, and all of the business logic segregated into individual functions. You don’t have to use functional with reactive; however, it forces you to do so and think this way, and when you do, you unlock a truly amazing architecture based on functional reactive programming, or simply FRP.Functional programming is a paradigm shift that can drastically transform the way in which you tackle solutions to any programming challenges. So, is functional programming a replacement for the more popular object-oriented design? Fortunately, applying functional programming to your code is not an “all or nothing,” approach as Michael Feathers noted in his quote at the beginning of this chapter. In fact, lots of applications can benefit from it when used alongside an object-oriented architecture. Due to rigid control for immutability and shared state, functional programming is also known for making multi-threaded programming more straightforward. Because JavaScript is a single-threaded platform, this is not something we need to worry about or cover in this book. In the next chapter I spend some time highlighting some of the key differences between functional and object-oriented design, which I believe will help you grok the functional way of thinking much easier.In this chapter, I briefly touched on topics that will be covered in depth throughout the book as you sink deeper into a functional frame of mind. If you’ve been following all of the concepts so far, that’s great, but don’t worry if you missed out a few things that just means you’ve picked up the right book. In traditional OOP, you are accustomed to programming in the imperative/procedural style; changing this will require you to make a drastic shift in your thought processes as you begin tackle problems the “functional way.”1.4	Summary ♣	Code that uses pure functions has zero chance of changing or breaking global state, which helps make your code be more testable and maintainable. ♣	Functional programming is done in a declarative style that is easier to reason about. This improves the overall readability of the application and makes your code leaner through a combination of functions and lambda expressions.♣	Data processing in a collection of elements is done fluently via function chains that link operations such as map and reduce.♣	Functional programming treats functions as building blocks by relying on first-class, high-order functions to improve the modularity and reusability of your code.Reduce the complexity of event-based programs by combining functional with reactive programming.
