#Higher-order PHP

I mentioned in chapter 1 that functional programming is not a new framework, library, or design pattern. It's a way of thinking that offers an alternative to the way in which you design your code. However, paradigms by themselves are just abstract concepts that need the right host language to become a reality. And, yes! PHP is that language. In this chapter, I'll take a look at two important features of PHP: higher-order functions and closures. Both of these are instrumental in building all of the techniques you'll learn about in this book.

##PHP's higher-order functions 
A higher-order function is defined as one that can accept other functions as arguments or be returned from another function. This is in direct relationship with another term you might've heard before, that has *first-class functions*. Both are intimately related, as the ability of a language artifact to be passed in as an argument or returned from a functions hinges on it being considered an object. This also means, of course, that functions can be assigned to variables. Let's take a look at a few examples: 

Functions in PHP can be manipulated just like objects. In fact, if you were to check the type of a function, you'll find out that they are instances of the class [`Closure`](http://php.net/manual/en/class.closure.php):

~~~
var_dump(function () { }); 

//-> class Closure#1 (0) {
     }
~~~

###Assign a function to a variable
This means that you should be able to treat a function just like any other type of object. Which means they can be assigned to variables. Consider a simple string concatenation function:
 
~~~
$concat2 = function ($s1, $s2) {
   return $s1. ' '. $s2;
};

$concat2('Hello', 'World');  //-> 'Hello World'
~~~

Behind the scenes this code takes the anonymous function (RHS) and assigns it to the variable `$concat2` (LHS). Alternatively, you can check for the presence of a function varible using [`is_callable()`](http://php.net/manual/en/function.is-callable.php):

~~~
is_callable($concat2) // 1
~~~ 

###Returned from a function
Functions can also be returned from another function. This is an extremely useful technique for creating families of functions. It's also the main part of implementing function currying, which you'll learn about in later chapters. Consider a simple `concatWith` function:

~~~
function concatWith($a) {
   return function ($b) use ($a) {
      return $a . $b;	
   };
}

$helloWith = concatWith('Hello');
$helloWith('World'); //-> 'Hello World'
~~~

###As a function parameter
Supplying functions as parameters allows you to administer specialized behavior on top of another function. Suppose I create a simple function that takes a *callable* (itself a function) and applies it onto its other parameters:

~~~
function apply(callable $operator, $a, $b) {
   return $operator($a, $b);
}
~~~

Through this *function argument*, I can inject any behavior I want:

~~~
$add = function ($a, $b) {
   return $a + $b;
};

$divide = function ($a, $b) {
   return $a / $b;
};

apply($add, 5, 5); //-> 10

apply($divide, 5, 5); //-> 10	
~~~

Consider a version of apply that's a bit more useful and expressive: 

~~~
function apply(callable $operator) {
   return function($a, $b) use ($operator) {
      return $operator($a, $b);
   };
}
~~~

Also, this code makes it very explicit what it's purpose is and I can use to derive other types of functions from it:

~~~
apply($add)(5, 5); //-> 10

apply($divide)(5, 5); //-> 1

// New function adder
$adder = apply($add);
$divider = apply($divide);

$adder(5,5); //-> 10
$divider(5,5); //-> 1
~~~

I mentioned earlier that higher-order functions allow you to supply specialized behavior via function arguments. Let's see this in action. What would happen if I call `apply($divide)(5, 0)`? Correct, a division by zero error:

~~~
Warning: Division by zero in .../code/src/ch02/ch02.php ...
~~~

To fix this, I'll create a function called `safeDivide` that  extra null-check logic. This function is a lot more resilient, returning PHP's NAN constant back to the caller.

~~~
/**
 * Divide two numbers
 * @return int | NAN
 */
$safeDivide = function ($a, $b) {   
   return empty($b) ? NAN : $a / $b;
};

apply($safeDivide)(5, 0); //-> NAN
~~~

The other reason why I prefer this approach is that checking for NAN requires a lot less effort and it's much cleaner than having to try and catch exceptions:

~~~
try {
   $result = apply($safeDivide)(5, 0);
   ...
   return $result;   
}
catch(Exception $e) {
    Log::error($e->getMessage());
}
~~~

This is a much better API design: 

~~~
$result = apply($safeDivide)(5, 0);
if(!is_nan($result)) {
   ...
   return $result;
}
else {
   Log::warning('Math error ocurred! Division by zero!');
}
~~~

This approach avoids throwing the exception altogether which is not only a side effect, as it causes the program stack to unwind, but also it respects the *Locality Principle* of design. In particular, it obeys *spatial locality*, which states that related statements that should be executed sequentially shall be placed near each other.  

To recap, this is all possible because PHP functions (including anonymous functions), as of PHP 5.3 are actually `Closure` instances behind the scenes. Before this version, this fact was just considered a design decision, but now you can reliably take advantage of this. In fact, because functions are true instances, as of PHP 5.4 you can actually invoke methods on them which gives you more control of the anonymous function after it's been created (as you might expect, closure instances all implement the magic method `__invoke()`, which is important for consistency reasons). 

http://php.net/manual/en/class.closure.php


CONTAINER


