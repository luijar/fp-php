#Higher-order PHP

I mentioned in chapter 1 that functional programming is not a new framework, library, or design pattern. It's a way of thinking that offers an alternative to the way in which you design your code. However, paradigms by themselves are just abstract concepts that need the right host language to become a reality. And, yes! PHP is that language. In this chapter, I'll take a look at two important features of PHP: higher-order functions and closures. Both of these are instrumental in building all of the techniques you'll learn about in this book.

##PHP's higher-order functions 
A higher-order function is defined as one that can accept other functions as arguments or be returned from another function. This is in direct relationship with another term you might've heard before, that has *first-class functions*. Both are intimately related, as the ability of a language artifact to be passed in as an argument or returned from a functions hinges on it being considered an object. This also means, of course, that functions can be assigned to variables. Let's take a look at a few examples: 

Functions in PHP can be manipulated just like objects. In fact, if you were to check the type of a function, you'll find out that they are instances of the class [`Closure`](http://php.net/manual/en/class.closure.php):

~~~
var_dump(function () { }); 

//-> class Closure#1 (0) {
     }
~~~

###Assign a function to a variable
This means that you should be able to treat a function just like any other type of object. Which means they can be assigned to variables. Consider a simple string concatenation function:
 
~~~
$concat2 = function ($s1, $s2) {
   return $s1. ' '. $s2;
};

$concat2('Hello', 'World');  //-> 'Hello World'
~~~

Behind the scenes this code takes the anonymous function (RHS) and assigns it to the variable `$concat2` (LHS). Alternatively, you can check for the presence of a function varible using [`is_callable()`](http://php.net/manual/en/function.is-callable.php):

~~~
is_callable($concat2) // 1
~~~ 

###Returned from a function
Functions can also be returned from another function. This is an extremely useful technique for creating families of functions. It's also the main part of implementing function currying, which you'll learn about in later chapters. Consider a simple `concatWith` function:

~~~
function concatWith($a) {
   return function ($b) use ($a) {
      return $a . $b;	
   };
}

$helloWith = concatWith('Hello');
$helloWith('World'); //-> 'Hello World'
~~~

###As a function parameter
Supplying functions as parameters allows you to administer specialized behavior on top of another function. Suppose I create a simple function that takes a *callable* (itself a function) and applies it onto its other parameters:

~~~
function apply(callable $operator, $a, $b) {
   return $operator($a, $b);
}
~~~

Through this *function argument*, I can inject any behavior I want:

~~~
$add = function ($a, $b) {
   return $a + $b;
};

$divide = function ($a, $b) {
   return $a / $b;
};

apply($add, 5, 5); //-> 10

apply($divide, 5, 5); //-> 10	
~~~

Consider a version of apply that's a bit more useful and expressive: 

~~~
function apply(callable $operator) {
   return function($a, $b) use ($operator) {
      return $operator($a, $b);
   };
}
~~~

Also, this code makes it very explicit what it's purpose is and I can use to derive other types of functions from it:

~~~
apply($add)(5, 5); //-> 10

apply($divide)(5, 5); //-> 1

// New function adder
$adder = apply($add);
$divider = apply($divide);

$adder(5,5); //-> 10
$divider(5,5); //-> 1
~~~

I mentioned earlier that higher-order functions allow you to supply specialized behavior via function arguments. Let's see this in action. What would happen if I call `apply($divide)(5, 0)`? Correct, a division by zero error:

~~~
Warning: Division by zero in .../code/src/ch02/ch02.php ...
~~~

To fix this, I'll create a function called `safeDivide` that  extra null-check logic. This function is a lot more resilient, returning PHP's NAN constant back to the caller.

~~~
$safeDivide = function ($a, $b) {   
   return empty($b) ? NAN : $a / $b;
};

apply($safeDivide)(5, 0); //-> NAN
~~~




