#Higher-order PHP
I mentioned in chapter 1 that functional programming is not a new framework, library, or design pattern. Rather, it's a way of thinking that offers an alternative to the way in which you design your code. However, paradigms by themselves are just abstract concepts that need the right host language to become a reality. And, yes! PHP is that language. In this chapter, I'll take a look at two important features of PHP: higher-order functions and closures. Both of these are instrumental in building all of the techniques you'll learn about in this book. The goal of this chapter is to teach you how to use functions in a very different way, the *functional* way.

##PHP's higher-order functions 
A higher-order function is defined as one that can accept other functions as arguments or be returned from another function. This is in direct relationship with another term you might've heard before, that has *first-class functions*. Both are intimately related, as the ability of a language artifact to be passed in as an argument or returned from a functions hinges on it being considered an object. This also means, of course, that functions can be assigned to variables. Let's take a look at a few examples: 

Functions in PHP can be manipulated just like objects. In fact, if you were to check the type of a function, you'll find out that they are instances of the class [`Closure`](http://php.net/manual/en/class.closure.php):

~~~
var_dump(function () { }); 

//-> class Closure#1 (0) {
     }
~~~

###Assign a function to a variable
This means that you should be able to treat a function just like any other type of object. Which means they can be assigned to variables. Consider a simple string concatenation function:
 
~~~
$concat2 = function ($s1, $s2) {
   return $s1. ' '. $s2;
};

$concat2('Hello', 'World');  //-> 'Hello World'
~~~

Behind the scenes this code takes the anonymous function (RHS) and assigns it to the variable `$concat2` (LHS). Alternatively, you can check for the presence of a function varible using [`is_callable()`](http://php.net/manual/en/function.is-callable.php):

~~~
is_callable($concat2) // 1
~~~ 

###Returned from a function
Functions can also be returned from another function. This is an extremely useful technique for creating families of functions. It's also the main part of implementing function currying, which you'll learn about in later chapters. Consider a simple `concatWith` function:

~~~
function concatWith($a) {
   return function ($b) use ($a) {
      return $a . $b;	
   };
}

$helloWith = concatWith('Hello');
$helloWith('World'); //-> 'Hello World'
~~~

###As a function parameter
Supplying functions as parameters allows you to administer specialized behavior on top of another function. Suppose I create a simple function that takes a *callable* (itself a function) and applies it onto its other parameters:

~~~
function apply(callable $operator, $a, $b) {
   return $operator($a, $b);
}
~~~

Through this *function argument*, I can inject any behavior I want:

~~~
$add = function ($a, $b) {
   return $a + $b;
};

$divide = function ($a, $b) {
   return $a / $b;
};

apply($add, 5, 5); //-> 10

apply($divide, 5, 5); //-> 10	
~~~

Consider a version of apply that's a bit more useful and expressive: 

~~~
function apply(callable $operator) {
   return function($a, $b) use ($operator) {
      return $operator($a, $b);
   };
}
~~~

Don't mind at this point the `use` keyword, I'll explain this further in a bit. Notice this code makes it very explicit what it's purpose is, and how I can use it to derive other types of functions from it. Let's go over some simple examples:

~~~
apply($add)(5, 5); //-> 10

apply($divide)(5, 5); //-> 1

// New function adder
$adder = apply($add);
$divider = apply($divide);

$adder(5,5); //-> 10
$divider(5,5); //-> 1
~~~

I mentioned earlier that higher-order functions allow you to supply specialized behavior via function arguments. Let's see this in action. What would happen if I call `apply($divide)(5, 0)`? Correct, a division by zero error:

~~~
Warning: Division by zero in .../code/src/ch02/ch02.php ...
~~~

To fix this, I'll create a function called `safeDivide` that  extra null-check logic. This function is a lot more resilient, returning PHP's NAN constant back to the caller.

~~~
/**
 * Divide two numbers
 * @return int | NAN
 */
$safeDivide = function ($a, $b) {   
   return empty($b) ? NAN : $a / $b;
};

apply($safeDivide)(5, 0); //-> NAN
~~~

The other reason why I prefer this approach is that checking for NAN requires a lot less effort and it's much cleaner than having to try and catch exceptions:

~~~
try {
   $result = apply($safeDivide)(5, 0);
   ...
   return $result;   
}
catch(Exception $e) {
    Log::error($e->getMessage());
}
~~~

This is a much better API design: 

~~~
$result = apply($safeDivide)(5, 0);
if(!is_nan($result)) {
   ...
   return $result;
}
else {
   Log::warning('Math error ocurred! Division by zero!');
}
~~~

This approach avoids throwing the exception altogether. Throwing anEeceptions is not only a side effect, as it causes the program stack to unwind, but also doesn't respect the *Locality Principle* of code. In particular, it fails to obey *spatial locality*, which states that related statements that should be executed sequentially shall be placed near each other. This has more application on CPU architecture, but can also be applied to code design.  

To recap, higher-order functions are possible in PHP because, as of PHP 5.3, they are actually `Closure` instances behind the scenes. Before this version, this was just considered an internal design decision, but now you can reliably take advantage of it to approach problems very differently. In this book, you'll learn to master higher-order functions. 

Furthermore, because functions are true instances, as of PHP 5.4 you can actually invoke methods on them which gives you more control of an anonymous function after it's been created (as you might expect, `Closure` instances all implement the magic method `__invoke()`, which is important for consistency reasons with other classes). 

http://php.net/manual/en/class.closure.php

CONTAINER

##Closures
TBD

##Liskov Substitution Principle
TBD

##What about our objects?

Treat as values
freeze PHP object
Lenses

##Functional vs Object-Oriented Summary

| Traits        | Functional           | Object-oriented  |
|:------------- |:-------------|:-----|
| Unit of composition      | Functions | Objects (classes) |
| Programming style     | Declarative      |   Mostly imperative |
| Data and Behavior | Loosely coupled into pure, standalone functions      |    Tightly coupled in classes with methods| 
|State Management | Treats objects as immutable values | Favors mutation of objects via instance methods |
|Control flow|Functions and recursion| Loops and conditionals|
|Tread-safety | Enables concurrent programming | Difficult to achieve |


